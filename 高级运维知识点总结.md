1. >/dev/null 2>&1 与 2>&1 >/dev/null的区别
```
默认情况下，总是有三个文件处于打开状态，标准输入(键盘输入)、标准输出（输出到屏幕）、标准错误（也是输出到屏幕），它们分别对应的文件描述符是0，1，2 。那么我们来看看下面的几种重定向方法的区别：

>/dev/null 2>&1 

实际上，等同于： 1>/dev/null 2>/dev/null ，默认情况下就是1，标准输出，所以一般都省略。 而&符号，后面接的是必须的文件描述符。含义：标准输出重定向到了/dev/null，而标准错误又重定向到了标准输出，所以就成了标准输出和标准错误都重定向到了/dev/null

2>&1 >/dev/null 

一条指令同一时刻要么产生标准错误，要么产生标准输出。 当产出标准错误的时候，因这个标准错误重定向到了标准输出，而标准输出是输出到屏幕。结果：标准错误打印到屏幕，而标准输出不打印到屏幕。

我们用表格来说明这两条命令的区别：

    命令      	标准输出	 错误输出
>/dev/null 2>&1	 丢弃	      丢弃
2>&1 >/dev/null	 丢弃	      屏幕
```
2. shell中$(( )) 与 $( ) 还有${ }的区别
```
一、 $( ) 与 ` ` (反引号)
在 bash shell 中，$( ) 与 ` ` (反引号) 都是用来做命令替换用的。
命令替换与变量替换差不多，都是用来重组命令行的，先完成引号里的命令行，然后将其结果替换出来，再重组新的命令行。

例如：
[root@localhost ~]# echo today is $(date "+%Y-%m-%d")
today is 2017-11-07
[root@localhost ~]# echo today is `date "+%Y-%m-%d"`
today is 2017-11-07

$( ) 的不足:
1. ` ` 基本上可用在全部的 unix shell 中使用，若写成 shell script ，其移植性比较高。
而 $( ) 并不见的每一种 shell 都能使用，若你用 bash2 是没啥问题的。


二、 ${ }变量替换

一般情况下，$var与${var}是没有区别的，但是用${ }会比较精确的界定变量名称的范围

[root@localhost ~]# A=Linux
[root@localhost ~]# echo $AB    #表示变量AB

[root@localhost ~]# echo ${A}B    #表示变量A后连接B
LinuxB

取路径、文件名、后缀

先赋值一个变量为一个路径，如下：
file=/dir1/dir2/dir3/my.file.txt

命令                  解释                            结果
${file#*/}    拿掉第一条 / 及其左边的字符串    dir1/dir2/dir3/my.file.txt
[root@localhost ~]# echo ${file#*/}
dir1/dir2/dir3/my.file.txt

${file##*/}    拿掉最后一条 / 及其左边的字符串    my.file.txt
[root@localhost ~]# echo ${file##*/}
my.file.txt

${file#*.}    拿掉第一个 . 及其左边的字符串      file.txt
[root@localhost ~]# echo ${file#*.}
file.txt

${file##*.}    拿掉最后一个 . 及其左边的字符串    txt
[root@localhost ~]# echo ${file##*.}
txt

${file%/*}    拿掉最后一条 / 及其右边的字符串     /dir1/dir2/dir3
[root@localhost ~]# echo ${file%/*}
/dir1/dir2/dir3

${file%%/*}    拿掉第一条 / 及其右边的字符串      (空值)
[root@localhost ~]# echo ${file%%/*}
(空值)

${file%.*}    拿掉最后一个 . 及其右边的字符串     /dir1/dir2/dir3/my.file
[root@localhost ~]# echo ${file%.*}
/dir1/dir2/dir3/my.file

${file%%.*}    拿掉第一个 . 及其右边的字符串      /dir1/dir2/dir3/my￼
[root@localhost ~]# echo ${file%%.*}
/dir1/dir2/dir3/my

记忆方法如下：

#是从左往右数匹配*号字符串前一个字符，作为分隔符，去掉左边字符，显示出剩余部分。
##是从右往左数匹配*号字符串前一个字符，作为分隔符，去掉左边字符，显示出剩余部分。

%是从右往左数匹配*号字符串前一个字符，作为分隔符，去掉右边字符，显示出剩余部分。

%%是从左往右数匹配*号字符串前一个字符，作为分隔符，去掉右边字符，显示出剩余部分。

# 是去掉左边(在键盘上 # 在 $ 之左边)
% 是去掉右边(在键盘上 % 在 $ 之右边)
单一符号是最小匹配;两个符号是最大匹配
*是用来匹配不要的字符，也就是想要去掉的那部分
还有指定字符分隔号，与*配合，决定取哪部分


取子串及替换

命令                                    解释                           　结果
${file:0:5}            　　　提取最左边的 5 个字节    　　　　　　　　　　　/dir1
${file:5:5}            　　　提取第 5 个字节右边的连续 5 个字节    　　　　 /dir2
${file/dir/path}            将第一个 dir 提换为 path    　　　　　　　　　 /path1/dir2/dir3/my.file.txt
${file//dir/path}    　　　　将全部 dir 提换为 path    　　　　　　　　　　 /path1/path2/path3/my.file.txt
${#file}    　　　　　　　　　 获取变量长度    　　　　　　　　　　　　　　　　　27                            
根据状态为变量赋值

命令	解释	备注
${file-my.file.txt}	若 $file 没设定,则使用 my.file.txt 作传回值	空值及非空值不作处理
${file:-my.file.txt}	若 $file 没有设定或为空值,则使用 my.file.txt 作传回值	非空值时不作处理
${file+my.file.txt}	若$file 设为空值或非空值,均使用my.file.txt作传回值	没设定时不作处理
${file:+my.file.txt}	若 $file 为非空值,则使用 my.file.txt 作传回值	没设定及空值不作处理
${file=txt}	若 $file 没设定,则回传 txt ,并将 $file 赋值为 txt	空值及非空值不作处理
${file:=txt}	若 $file 没设定或空值,则回传 txt ,将 $file 赋值为txt	非空值时不作处理
${file?my.file.txt}	若 $file 没设定,则将 my.file.txt 输出至 STDERR	空值及非空值不作处理
${file:?my.file.txt}	若 $file没设定或空值,则将my.file.txt输出至STDERR	非空值时不作处理


三、 $(( ))整数运算

$(( ))作用：它是用来作整数运算的。
在 bash 中，$(( )) 的整数运算符号大致有这些：
+ - * / ：分别为 "加、减、乘、除"。
% ：余数运算
& | ^ !：分别为 "AND、OR、XOR、NOT" 运算。

例：
$ a=5; b=7; c=2
$ echo $(( a+b*c ))
19
$ echo $(( (a+b)/c ))
6
$ echo $(( (a*b)%c))
1

在 $(( )) 中的变量名称，可于其前面加 $ 符号来替换，也可以不用，如：
$(( $a + $b * $c)) 也可得到 19 的结果

事实上，单纯用 (( )) 也可重定义变量值，或作 testing：
a=5; ((a++)) 可将 $a 重定义为 6 
a=5; ((a–)) 则为 a=4
a=5; b=7; ((a < b)) 会得到   0 (true) 的返回值。

常见的用于 (( )) 的测试符号有如下这些：
<：小于
>：大于
<=：小于或等于
>=：大于或等于
==：等于
!=：不等于
